/**
 * HIPAA-Compliant Logging Service - Database Agnostic
 * 
 * Features:
 * - No PHI in logs
 * - Sanitized error messages
 * - Audit trail for compliance
 * - Environment-based log levels
 * - Pluggable storage backends (Firestore, PostgreSQL, MongoDB, etc.)
 */

export enum LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3,
    AUDIT = 4, // For HIPAA audit trail
}

export enum AuditEventType {
    PHI_ACCESS = 'PHI_ACCESS',
    PHI_MODIFY = 'PHI_MODIFY',
    PHI_DELETE = 'PHI_DELETE',
    PHI_EXPORT = 'PHI_EXPORT',
    LOGIN = 'LOGIN',
    LOGOUT = 'LOGOUT',
    FAILED_LOGIN = 'FAILED_LOGIN',
    PASSWORD_CHANGE = 'PASSWORD_CHANGE',
    PERMISSION_CHANGE = 'PERMISSION_CHANGE',
    SESSION_START = 'SESSION_START',
    SESSION_END = 'SESSION_END',
    PAYMENT = 'PAYMENT',
}

export interface LogEntry {
    timestamp: string;
    level: LogLevel;
    message: string;
    context?: Record<string, any>;
    userId?: string;
    sessionId?: string;
}

export interface AuditEntry {
    id?: string; // Auto-generated by storage backend
    timestamp: string;
    eventType: AuditEventType;
    userId: string;
    resourceId?: string;
    resourceType?: string;
    action: string;
    ipAddress?: string;
    userAgent?: string;
    success: boolean;
    metadata?: Record<string, any>;
}

/**
 * Storage Backend Interface
 * Implement this for your chosen database
 */
export interface LogStorageBackend {
    saveLog(entry: LogEntry): Promise<void>;
    saveAudit(entry: AuditEntry): Promise<void>;
    getLogs(filters?: LogFilters): Promise<LogEntry[]>;
    getAudits(filters?: AuditFilters): Promise<AuditEntry[]>;
    getAuditStats(): Promise<AuditStats>;
}

export interface LogFilters {
    startDate?: Date;
    endDate?: Date;
    level?: LogLevel;
    userId?: string;
    limit?: number;
}

export interface AuditFilters {
    startDate?: Date;
    endDate?: Date;
    userId?: string;
    eventType?: AuditEventType;
    resourceType?: string;
    limit?: number;
}

export interface AuditStats {
    totalEvents: number;
    eventsByType: Record<string, number>;
    eventsByUser: Record<string, number>;
    recentEvents: AuditEntry[];
    failedAttempts: number;
}

/**
 * In-Memory Storage (Development Only)
 */
class InMemoryStorage implements LogStorageBackend {
    private logs: LogEntry[] = [];
    private audits: AuditEntry[] = [];

    async saveLog(entry: LogEntry): Promise<void> {
        this.logs.push(entry);
        // Keep only last 1000 logs in memory
        if (this.logs.length > 1000) {
            this.logs = this.logs.slice(-1000);
        }
    }

    async saveAudit(entry: AuditEntry): Promise<void> {
        this.audits.push({ ...entry, id: `audit_${Date.now()}_${Math.random()}` });
    }

    async getLogs(filters?: LogFilters): Promise<LogEntry[]> {
        let filtered = [...this.logs];

        if (filters?.startDate) {
            filtered = filtered.filter(log => new Date(log.timestamp) >= filters.startDate!);
        }
        if (filters?.endDate) {
            filtered = filtered.filter(log => new Date(log.timestamp) <= filters.endDate!);
        }
        if (filters?.level !== undefined) {
            filtered = filtered.filter(log => log.level === filters.level);
        }
        if (filters?.userId) {
            filtered = filtered.filter(log => log.userId === filters.userId);
        }
        if (filters?.limit) {
            filtered = filtered.slice(-filters.limit);
        }

        return filtered;
    }

    async getAudits(filters?: AuditFilters): Promise<AuditEntry[]> {
        let filtered = [...this.audits];

        if (filters?.startDate) {
            filtered = filtered.filter(a => new Date(a.timestamp) >= filters.startDate!);
        }
        if (filters?.endDate) {
            filtered = filtered.filter(a => new Date(a.timestamp) <= filters.endDate!);
        }
        if (filters?.userId) {
            filtered = filtered.filter(a => a.userId === filters.userId);
        }
        if (filters?.eventType) {
            filtered = filtered.filter(a => a.eventType === filters.eventType);
        }
        if (filters?.resourceType) {
            filtered = filtered.filter(a => a.resourceType === filters.resourceType);
        }
        if (filters?.limit) {
            filtered = filtered.slice(-filters.limit);
        }

        return filtered.reverse(); // Most recent first
    }

    async getAuditStats(): Promise<AuditStats> {
        const eventsByType: Record<string, number> = {};
        const eventsByUser: Record<string, number> = {};
        let failedAttempts = 0;

        this.audits.forEach(audit => {
            eventsByType[audit.eventType] = (eventsByType[audit.eventType] || 0) + 1;
            eventsByUser[audit.userId] = (eventsByUser[audit.userId] || 0) + 1;
            if (!audit.success) failedAttempts++;
        });

        return {
            totalEvents: this.audits.length,
            eventsByType,
            eventsByUser,
            recentEvents: this.audits.slice(-10).reverse(),
            failedAttempts,
        };
    }
}

class SecureLogger {
    private minLogLevel: LogLevel;
    private isDevelopment: boolean;
    private storage: LogStorageBackend;

    constructor(storage?: LogStorageBackend) {
        this.isDevelopment = typeof import.meta !== 'undefined' && import.meta.env?.DEV === true ||
            (typeof process !== 'undefined' && process.env?.NODE_ENV === 'development');
        this.minLogLevel = this.isDevelopment ? LogLevel.DEBUG : LogLevel.WARN;
        this.storage = storage || new InMemoryStorage();
    }

    /**
     * Set custom storage backend
     */
    setStorage(storage: LogStorageBackend): void {
        this.storage = storage;
    }

    /**
     * Sanitize data to remove any potential PHI
     */
    private sanitize(data: any): any {
        if (typeof data === 'string') {
            data = data.replace(/[\w.-]+@[\w.-]+\.\w+/g, '[EMAIL_REDACTED]');
            data = data.replace(/\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g, '[PHONE_REDACTED]');
            data = data.replace(/\b\d{3}-\d{2}-\d{4}\b/g, '[SSN_REDACTED]');
            return data;
        }

        if (typeof data === 'object' && data !== null) {
            const sanitized: any = Array.isArray(data) ? [] : {};
            for (const key in data) {
                if (this.isSensitiveField(key)) {
                    sanitized[key] = '[REDACTED]';
                } else {
                    sanitized[key] = this.sanitize(data[key]);
                }
            }
            return sanitized;
        }

        return data;
    }

    private isSensitiveField(fieldName: string): boolean {
        const sensitivePatterns = [
            'password', 'ssn', 'social', 'dob', 'dateofbirth',
            'diagnosis', 'medical', 'health', 'treatment', 'medication',
            'insurance', 'creditcard', 'cardnumber', 'cvv', 'token', 'secret',
        ];

        const lowerField = fieldName.toLowerCase();
        return sensitivePatterns.some(pattern => lowerField.includes(pattern));
    }

    private async log(level: LogLevel, message: string, context?: Record<string, any>): Promise<void> {
        if (level < this.minLogLevel) return;

        const entry: LogEntry = {
            timestamp: new Date().toISOString(),
            level,
            message: this.sanitize(message),
            context: context ? this.sanitize(context) : undefined,
        };

        // Console log in development
        if (this.isDevelopment) {
            const levelName = LogLevel[level];
            const emoji = this.getLogEmoji(level);
            console.log(`${emoji} [${levelName}] ${entry.message}`, entry.context || '');
        }

        // Save to storage backend
        try {
            await this.storage.saveLog(entry);
        } catch (error) {
            console.error('Failed to save log to storage', error);
        }
    }

    private getLogEmoji(level: LogLevel): string {
        switch (level) {
            case LogLevel.DEBUG: return 'ðŸ”';
            case LogLevel.INFO: return 'â„¹ï¸';
            case LogLevel.WARN: return 'âš ï¸';
            case LogLevel.ERROR: return 'âŒ';
            case LogLevel.AUDIT: return 'ðŸ“‹';
            default: return 'ðŸ“';
        }
    }

    debug(message: string, context?: Record<string, any>): void {
        this.log(LogLevel.DEBUG, message, context);
    }

    info(message: string, context?: Record<string, any>): void {
        this.log(LogLevel.INFO, message, context);
    }

    warn(message: string, context?: Record<string, any>): void {
        this.log(LogLevel.WARN, message, context);
    }

    error(message: string, error?: Error | unknown, context?: Record<string, any>): void {
        const errorContext = {
            ...context,
            error: error instanceof Error ? {
                message: this.sanitize(error.message),
                stack: this.isDevelopment ? error.stack : '[REDACTED]',
                name: error.name,
            } : this.sanitize(String(error)),
        };

        this.log(LogLevel.ERROR, message, errorContext);
    }

    /**
     * HIPAA Audit Logging
     */
    async audit(entry: Omit<AuditEntry, 'timestamp'>): Promise<void> {
        const auditEntry: AuditEntry = {
            timestamp: new Date().toISOString(),
            ...entry,
        };

        try {
            await this.storage.saveAudit(auditEntry);
        } catch (error) {
            console.error('CRITICAL: Failed to write audit log', error);
        }

        if (this.isDevelopment) {
            console.log('ðŸ“‹ [AUDIT]', auditEntry);
        }
    }

    /**
     * Get logs (Super Admin only)
     */
    async getLogs(filters?: LogFilters): Promise<LogEntry[]> {
        return this.storage.getLogs(filters);
    }

    /**
     * Get audit logs (Super Admin only)
     */
    async getAudits(filters?: AuditFilters): Promise<AuditEntry[]> {
        return this.storage.getAudits(filters);
    }

    /**
     * Get audit statistics (Super Admin only)
     */
    async getAuditStats(): Promise<AuditStats> {
        return this.storage.getAuditStats();
    }
}

// Export singleton instance
export const logger = new SecureLogger();

// Export helper for common PHI access logging
export const auditPHIAccess = (
    userId: string,
    resourceId: string,
    resourceType: string,
    action: string
) => {
    logger.audit({
        eventType: AuditEventType.PHI_ACCESS,
        userId,
        resourceId,
        resourceType,
        action,
        success: true,
        ipAddress: typeof window !== 'undefined' ? window.location.hostname : undefined,
        userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : undefined,
    });
};
